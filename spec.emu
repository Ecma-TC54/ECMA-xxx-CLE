<!DOCTYPE html>
<html lang="en-GB-oxendict">
<meta charset="utf-8">
<link rel="icon" href="img/favicon.ico">
<style media="print">
  #sec-example pre {
    break-inside: auto;
  }
</style>
<pre class="metadata">
  title: Common Lifecycle Enumeration (CLE) specification
  shortname: ECMA-xxx
  status: standard
  location: https://tc54.org/ecmaXXX/
  markEffects: true
  version: 1<sup>st</sup> Edition
</pre>
<p><img src="img/ecma-logo.svg" id="ecma-logo" alt="Ecma International logo"></p>
<div id="metadata-block">
  <h1>About this Standard</h1>
  <p>The document at <a href="https://tc54.org/ecmaXXX/">https://tc54.org/ecmaXXX/</a> is the most accurate and up-to-date Common Lifecycle Enumeration specification.</p>
  <p>This document is available as <a href>a single page</a> and as <a href="./multipage/">multiple pages</a>.</p>
  <h1>Contributing to this Standard</h1>
  <p>This standard is developed on GitHub with the help of the OWASP community. There are a number of ways to contribute to the development of this standard:</p>
  <ul>
    <li>GitHub Repository: <a href="https://github.com/Ecma-TC54/ECMA-xxx-CLE">https://github.com/Ecma-TC54/ECMA-xxx-CLE</a></li>
    <li>Issues: <a href="https://github.com/Ecma-TC54/ECMA-xxx-CLE/issues">All Issues</a>, <a href="https://github.com/Ecma-TC54/ECMA-xxx-CLE/issues/new">File a New Issue</a></li>
    <li>Pull Requests: <a href="https://github.com/Ecma-TC54/ECMA-xxx-CLE/pulls">All Pull Requests</a>, <a href="https://github.com/Ecma-TC54/ECMA-xxx-CLE/pulls/new">Create a New Pull Request</a></li>
    <li>
      Editors:
      <ul>
        <li><a href="mailto:benji@xeol.io">Benji Visser</a></li>
        <li><a href="mailto:ljharb@gmail.com">Jordan Harband</a></li>
        <li><a href="mailto:steve.springett@owasp.org">Steve Springett</a></li>
      </ul>
    </li>
    <li>
      Community:
      <ul>
        <li>Chat: <a href="https://owasp.slack.com/archives/C06GUKY03NC">Slack Channel</a></li>
      </ul>
    </li>
  </ul>
  <p>Refer to the <emu-xref href="#sec-colophon">colophon</emu-xref> for more information on how this document is created.</p>
</div>

<!-- Common Lifecycle Enumeration Specification -->

<emu-intro id="sec-intro">
  <h1>Introduction</h1>
  <p>The Common Lifecycle Enumeration (CLE) specification provides a standardized, machine-readable format for communicating lifecycle events of software and hardware components throughout the supply chain. As modern software systems increasingly rely on complex networks of dependencies and third-party components, understanding the lifecycle status of these components becomes critical for maintaining secure, compliant, and reliable systems.</p>

  <p>This standard addresses the challenge of tracking component lifecycles across diverse ecosystems by defining a unified format for expressing events such as releases, end-of-support announcements, end-of-life declarations, and component transitions. By providing a consistent structure for this information, CLE enables automated tooling to assess risks, plan migrations, and maintain supply chain transparency.</p>

  <p>The CLE specification is designed to complement existing standards in the software supply chain ecosystem, including the Package-URL (PURL) specification for component identification and the Version Range (VERS) specification (inlined <emu-xref href="#sec-vers">here</emu-xref>, pending standardization) for version constraints. It integrates with Software Bill of Materials (SBOM) formats and transparency exchange protocols to provide comprehensive lifecycle visibility.</p>

  <p>This document specifies version 1.0.0 of the Common Lifecycle Enumeration standard, developed under the auspices of Ecma International Technical Committee 54, Task Group 3 (TC54-TG3).</p>

  <p class="adoption-info">This Ecma Standard was developed by Technical Committee 54 and was adopted by the General Assembly of December 2025.</p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>Scope</h1>
  <p>This Standard defines the Common Lifecycle Enumeration (CLE) specification version 1.0.0. The CLE provides a standardized format for communicating software component lifecycle events in a machine-readable format. This standard defines the JSON schema and requirements for CLE documents.</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>Conformance</h1>
  <p>A conforming implementation of CLE must provide and consume objects that conform to the JSON Schema defined in this Standard. The key words "must", "must not", "required", "shall", "shall not", "should", "should not", "recommended", "may", and "optional" in this document are to be interpreted as described in RFC 2119.</p>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>Normative references</h1>
  <p>The following documents are referred to in the text in such a way that some or all of their content constitutes requirements of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
  <p>
    ECMA-XXX, <i>Package-URL (PURL) Specification</i><br/>
    <a href="https://ecma-tc54.github.io/ECMA-xxx-PURL/">https://ecma-tc54.github.io/ECMA-xxx-PURL/</a>
  </p>
  <p>
    <i>Version Range (VERS) Specification</i><br/>
    <emu-xref href="#sec-vers"></emu-xref>
  </p>
  <p>
    ISO 8601, <i>Date and time — Representations for information interchange</i><br/>
    <a href="https://www.iso.org/standard/70907.html">https://www.iso.org/standard/70907.html</a>
  </p>
  <p>
    JSON Schema Draft 2020-12<br/>
    <a href="https://json-schema.org/draft/2020-12/json-schema-core">https://json-schema.org/draft/2020-12/json-schema-core</a>
  </p>
  <p>
    IETF RFC 2119, <i>Key words for use in RFCs to Indicate Requirement Levels</i><br>
    <a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>
  </p>
</emu-clause>

<emu-clause id="sec-terms-and-definitions">
  <h1>Terms and definitions</h1>

  <emu-clause id="sec-component">
    <h1>component</h1>
    <p>A discrete unit of software or hardware that can be independently identified, versioned, and tracked through its lifecycle.</p>
  </emu-clause>

  <emu-clause id="sec-lifecycle-event">
    <h1>lifecycle event</h1>
    <p>A significant occurrence in the existence of a component, such as release, end of support, or renaming.</p>
  </emu-clause>

  <emu-clause id="sec-purl">
    <h1>PURL</h1>
    <p>Package-URL - a standardized format for identifying software packages across diverse ecosystems.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-types-of-work">
  <h1>Types of work</h1>
  <p>The following types of work are commonly associated with software projects regardless of whether they are open source or not:</p>
  <ul>
    <li><b>Marketing</b>: Promoting and advertising a software project to potential users.</li>
    <li><b>Substantial Modifications</b>: Making substantial changes to a software project that are not considered bug fixes or security fixes, such as adding new features or functionality.</li>
    <li><b>Bug Fixes</b>: Addressing and resolving issues or defects in a software project.</li>
    <li><b>Security Fixes</b>: A distinct type of bug fix focused on security vulnerabilities that is useful to differentiate from other types of bug fixes.</li>
    <li><b>Distribution</b>: The process of making a software project available for use by others.</li>
    <li><b>Documentation</b>: Writing and updating documentation for a software project to help users understand how to use it.</li>
  </ul>
</emu-clause>

<emu-clause id="sec-schema-definition">
  <h1>Schema definition</h1>

  <emu-clause id="sec-json-schema">
    <h1>JSON Schema</h1>
    <p>CLE is formally specified by a Draft 2020-12 JSON Schema.</p>
    <p>Each published version of the specification is accompanied by a versioned meta-schema at a stable URI:</p>
    <pre><code>https://cle.example.com/schema/cle-&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;.schema.json</code></pre>
    <p>Every CLE document must include a top-level <code>$schema</code> field whose value is the URI of the meta-schema for the version it follows.</p>
    <p>The <code>$schema</code> field serves two purposes:</p>
    <ul>
      <li><b>Validation</b> – It allows tooling to validate that the document is structurally correct and conforms to the CLE specification.</li>
      <li><b>Version Signaling</b> – It identifies the version of the CLE specification the document follows, so consumers can parse and interpret it accordingly.</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-top-level-fields">
    <h1>Top-level fields</h1>

    <emu-table id="table-required-fields" caption="Required Fields">
      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>$schema</code></td>
            <td>string</td>
            <td>URI identifying the JSON Schema document that describes the version of the CLE schema to use.</td>
          </tr>
          <tr>
            <td><code>identifier</code></td>
            <td>string or array[string]</td>
            <td>Component identifier(s) in the PURL format. When an array is provided, each identifier alias must identify the exact same bits from the same software but distributed differently.</td>
          </tr>
          <tr>
            <td><code>updatedAt</code></td>
            <td>string</td>
            <td>ISO 8601 timestamp indicating when this CLE document was last updated.</td>
          </tr>
          <tr>
            <td><code>events</code></td>
            <td>array</td>
            <td>Ordered array of Event objects representing the component's lifecycle events. Must be ordered by ID in descending order (newest events with highest IDs first).</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-table id="table-additional-fields" caption="Additional Fields">
      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>definitions</code></td>
            <td>object</td>
            <td>Container for reusable policy definitions that can be referenced throughout the document.</td>
          </tr>
          <tr>
            <td><code>index</code></td>
            <td>string</td>
            <td>URL pointing to the index file that lists all CLE pages for this component. Only allowed to be present when pagination is used.</td>
          </tr>
          <tr>
            <td><code>next</code></td>
            <td>string</td>
            <td>URL pointing to the next CLE page containing newer events (higher event IDs).</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-definitions-object">
    <h1>Definitions object</h1>
    <p>The definitions object allows specification of reusable policies and calculations that can be referenced by events.</p>

    <emu-clause id="sec-support-definitions">
      <h1>Support definitions</h1>
      <p>The support object defines the support policies provided for a specific version or version range of a component. This may include first-party manufacturer support or third-party support options endorsed by the manufacturer.</p>
      <p>Support policies are immutable once defined - the semantics and meaning of a support policy must not change over time for a given support policy ID. This ensures consistent interpretation of support commitments across the component's lifecycle.</p>

      <emu-table id="table-support-policy-fields" caption="Support Policy Fields">
        <table>
          <thead>
            <tr>
              <th>Field</th>
              <th>Type</th>
              <th>Required</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>id</code></td>
              <td>string</td>
              <td>Yes</td>
              <td>Unique identifier for the support policy.</td>
            </tr>
            <tr>
              <td><code>description</code></td>
              <td>string</td>
              <td>Yes</td>
              <td>Human readable description of the policy.</td>
            </tr>
            <tr>
              <td><code>url</code></td>
              <td>string</td>
              <td>No</td>
              <td>URL to detailed documentation about this support policy.</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-event-object">
    <h1>Event object</h1>
    <p>The base object that represents a discrete lifecycle event. All events share these common fields.</p>
    <p>Events are immutable once created - the content and meaning of a specific event must not change after it has been published. Additionally, the ordering of events across shards must not change.</p>

    <emu-table id="table-event-required-fields" caption="Event Required Fields">
      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>id</code></td>
            <td>integer</td>
            <td>A unique, auto-incrementing integer identifier for the event.</td>
          </tr>
          <tr>
            <td><code>type</code></td>
            <td>string</td>
            <td>The type of lifecycle event. Must be one of the defined Event Types.</td>
          </tr>
          <tr>
            <td><code>effective</code></td>
            <td>string</td>
            <td>The time when the event takes effect, as an ISO 8601 formatted timestamp in UTC.</td>
          </tr>
          <tr>
            <td><code>published</code></td>
            <td>string</td>
            <td>The time when the event was first published, as an ISO 8601 formatted timestamp in UTC.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-event-types">
  <h1>Event types</h1>

  <emu-clause id="sec-event-type-released">
    <h1>released</h1>
    <p><i>Category: Version Event</i></p>
    <p>Indicates when a component version is released and available for use.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>version</code> - The version string of the released component</li>
    </ul>
    <p><b>Additional Optional Fields:</b></p>
    <ul>
      <li><code>license</code> - License identifier that summarizes the license as declared in the component's metadata</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-endofdevelopment">
    <h1>endOfDevelopment</h1>
    <p><i>Category: Version Event</i></p>
    <p>The manufacturer or maintainer ceases work on Substantial Modifications for a specific version or version range of a component or service. Security Fixes and Bug Fixes will continue to be provided for this specific version or version range until endOfSupport is declared, but no new features or enhancements will be added.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>versions</code> - Array of version specifications, per <emu-xref href="#sec-vers"></emu-xref></emu-xref></li>
      <li><code>supportId</code> - Reference to a support policy defined in the definitions section</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-endofsupport">
    <h1>endOfSupport</h1>
    <p><i>Category: Version Event</i></p>
    <p>The manufacturer or maintainer ceases providing Security Fixes and Bug Fixes for a specific version or version range of a component or service.</p>
    <p>The <code>supportId</code> field must be included and used to specify which support policy is ending, referencing a support policy defined in the definitions section.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>versions</code> - Array of version specifications</li>
      <li><code>supportId</code> - Reference to a support policy defined in the definitions section</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-endoflife">
    <h1>endOfLife</h1>
    <p><i>Category: Version Event</i></p>
    <p>The manufacturer or maintainer formally ceases all work (including Distribution, Substantial Modifications, Bug Fixes, Security Fixes, Documentation, and Maintenance) for a specific version or version range of a component. No further updates, support, or distribution will be provided for this specific version or version range. The component is considered retired.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>versions</code> - Array of version specifications, per <emu-xref href="#sec-vers"></emu-xref></li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-endofdistribution">
    <h1>endOfDistribution</h1>
    <p><i>Category: Version Event</i></p>
    <p>The manufacturer or maintainer ceases distribution of a specific version or version range of a component or service. This should only be used when the manufacturer has control over the distribution of the component or service.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>versions</code> - Array of version specifications, per <emu-xref href="#sec-vers"></emu-xref></li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-endofmarketing">
    <h1>endOfMarketing</h1>
    <p><i>Category: Version Event</i></p>
    <p>The manufacturer or maintainer ceases marketing and promotion of a specific version or version range of a component or service. The component or service may still be available, and existing support policies may remain in effect, but the manufacturer will no longer seek new customers or promote its use.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>versions</code> - Array of version specifications, per <emu-xref href="#sec-vers"></emu-xref></li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-supersededby">
    <h1>supersededBy</h1>
    <p><i>Category: Version Event</i></p>
    <p>Indicates when a version of a component is superseded by another version of a component. This should only exist for components in which version progression is not implicit.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>supersededByVersion</code> - Plain version string that supersedes it</li>
    </ul>
    <p><b>Additional Optional Fields:</b></p>
    <ul>
      <li><code>versions</code> - Array of version specifications, per <emu-xref href="#sec-vers"></emu-xref></li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-componentrenamed">
    <h1>componentRenamed</h1>
    <p><i>Category: Component Event</i></p>
    <p>Indicates when a component is renamed.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>identifiers</code> - Array of identifier objects specifying the new identifiers for the component</li>
    </ul>
    <p><b>Additional Optional Fields:</b></p>
    <ul>
      <li><code>description</code> - Human-readable description of the event</li>
      <li><code>references</code> - List of URLs to supporting documentation</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-event-type-withdrawn">
    <h1>withdrawn</h1>
    <p><i>Category: Meta Event</i></p>
    <p>Indicates that a previously published event is being withdrawn or revoked. This is used in a prepend-only event model where events cannot be modified, only new events can be added. When an event is withdrawn, it should be ignored during processing as if it never existed.</p>
    <p><b>Additional Required Fields:</b></p>
    <ul>
      <li><code>eventId</code> - The ID of the event being withdrawn</li>
    </ul>
    <p><b>Additional Optional Fields:</b></p>
    <ul>
      <li><code>references</code> - List of URLs to supporting documentation</li>
      <li><code>reason</code> - Human-readable explanation for why the event is being withdrawn</li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-event-categories">
  <h1>Event categories</h1>
  <p>The CLE specification supports three distinct categories of events:</p>

  <emu-clause id="sec-version-events">
    <h1>Version events</h1>
    <p>Events that affect specific <emu-xref href="#sec-vers">versions or ranges of versions</emu-xref> of a component. These events use either the <code>version</code> or <code>range</code> field to specify which versions are affected. Version Events include:</p>
    <ul>
      <li><code>released</code></li>
      <li><code>endOfDevelopment</code></li>
      <li><code>endOfSupport</code></li>
      <li><code>endOfLife</code></li>
      <li><code>endOfDistribution</code></li>
      <li><code>endOfMarketing</code></li>
      <li><code>supersededBy</code></li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-component-events">
    <h1>Component events</h1>
    <p>Events that affect the component itself and may impact how the component is identified or referenced. These events often affect all versions of a component from the effective date forward. Component Events include:</p>
    <ul>
      <li><code>componentRenamed</code> - Changes how the component is identified</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-meta-events">
    <h1>Meta events</h1>
    <p>Events that affect other events in the history. These are used in the prepend-only event model to manage the event stream. Meta Events include:</p>
    <ul>
      <li><code>withdrawn</code> - Revokes a previously published event</li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-event-processing-rules">
  <h1>Event processing rules</h1>
  <p>CLE uses a prepend-only event model with the following rules:</p>

  <emu-alg>
    1. <b>Immutability</b>: Once an event is published, it cannot be modified. New events must be added to correct or update information.
    1. <b>Ordering</b>: Events must be ordered by ID in descending order (newest events with highest IDs first).
    1. <b>ID Assignment</b>: Event IDs must be assigned as auto-incrementing integers in the order events are added (not by effective date).
    1. <b>Processing Order</b>: When processing events, consumers should process them in reverse order (oldest to newest by ID) to build the correct state.
    1. <b>Withdrawn Events</b>: When a <code>withdrawn</code> event is encountered:
      1. The event referenced by <code>eventId</code> should be ignored as if it never existed.
      1. The withdrawn event itself remains in the history for audit purposes.
      1. Any dependent events or calculations based on the withdrawn event should be recalculated.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-pagination">
  <h1>Pagination</h1>
  <p>CLE supports pagination to handle components with extensive event histories. When a CLE file reaches the maximum limit of 100,000 events, it must be split into multiple pages.</p>

  <emu-clause id="sec-pagination-rules">
    <h1>Pagination rules</h1>
    <emu-alg>
      1. <b>Page Size Limit</b>: A single CLE page must not exceed 100,000 events.
      1. <b>Event ID Continuity</b>: Event IDs must be globally unique and incrementing across all pages.
      1. <b>Event Ordering</b>: Within each page, events must be ordered by ID in descending order.
      1. <b>Page Chaining</b>: Pages are linked using the <code>next</code> field.
      1. <b>Index File</b>: When pagination is used, an index file SHOULD be provided via the <code>index</code> field.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-cle-index-schema">
    <h1>CLE index schema</h1>
    <p>The CLE index file provides a directory of all pages for a component.</p>

    <emu-table id="table-index-fields" caption="Index Fields">
      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Required</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>$schema</code></td>
            <td>string</td>
            <td>Yes</td>
            <td>URI identifying the CLE index schema version.</td>
          </tr>
          <tr>
            <td><code>pages</code></td>
            <td>array[object]</td>
            <td>Yes</td>
            <td>Array of page descriptor objects, ordered by event ID ranges.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-table id="table-page-descriptor-fields" caption="Page Descriptor Fields">
      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Required</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>url</code></td>
            <td>string</td>
            <td>Yes</td>
            <td>URL of the CLE page file.</td>
          </tr>
          <tr>
            <td><code>firstEventId</code></td>
            <td>integer</td>
            <td>Yes</td>
            <td>The lowest event ID in this page.</td>
          </tr>
          <tr>
            <td><code>lastEventId</code></td>
            <td>integer</td>
            <td>Yes</td>
            <td>The highest event ID in this page.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-processing-paginated-files">
    <h1>Processing paginated CLE files</h1>
    <p>When processing paginated CLE files:</p>
    <emu-alg>
      1. Start with any page (typically discovered via the index file or a known entry point).
      1. Process events within the current page according to standard processing rules.
      1. To process all events, use the index file to discover all pages, or follow <code>next</code> links to traverse pages.
      1. Event IDs are globally unique, so <code>withdrawn</code> events can reference events on any page.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-use-cases">
  <h1>Use cases</h1>
  <p>The CLE specification aims to address several common use cases in software component lifecycle management.</p>

  <emu-clause id="sec-supported-use-cases">
    <h1>v1.0.0 supported use cases</h1>
    <ul>
      <li><b>General Availability</b>: Track when new versions of a component are released and available for use.</li>
      <li><b>End of Support/End of Life</b>: Communicate when versions will no longer receive updates or support.</li>
      <li><b>Component Renaming</b>: Handle cases where a component's identifiers change.</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-future-use-cases">
    <h1>Future use cases</h1>
    <p>These use cases will be addressed in future versions of the specification based on community feedback and requirements:</p>
    <ul>
      <li><b>Complex License Changes</b>: Handling license changes for previously released versions.</li>
      <li><b>Component Bundling/Unbundling</b>: Track when components are bundled into or extracted from larger packages.</li>
      <li><b>Component Acquisition</b>: Handle cases where components change ownership.</li>
      <li><b>Extended Support</b>: Support for third-party extended support offerings.</li>
      <li><b>Third Party Claims</b>: Handling CLE from a third party perspective.</li>
      <li><b>Component Forking</b>: Track when components are forked into new projects.</li>
      <li><b>Export Restrictions</b>: Handle cases where components become restricted in certain regions.</li>
      <li><b>Security Status Changes</b>: Track when components are marked as compromised or unsafe.</li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-annex normative id="sec-vers">
  <h1>Version Range (VERS) Specification (Inlined)</h1>

  <p>This specification is a new syntax for dependency and vulnerable version
ranges.</p>

  <h2>Version range specifier</h2>

  <p>A version range specifier (aka. "vers") is a URI string using the `vers` URI-scheme with this syntax:</p>

  <pre>
    vers:&lt;versioning-scheme&gt;/&lt;version-constraint&gt;|&lt;version-constraint&gt;|...
  </pre>

  <p>
    For example, to define a set of versions that contains either version `1.2.3`, or any versions greater than or equal to `2.0.0` but less than ``5.0.0` using the `node-semver` versioning scheme used with the `npm` Package-URL type, the version range specifier will be:
  </p>

  <pre>
    vers:npm@1.2.3|&rt;=2.0.0|&lt;5.0.0
  </pre>

  <p>
    `vers` is the URI-scheme and is an acronym for "VErsion Range Specifier". It has been selected because it is short, obviously about version and available for a future formal URI-scheme registration at IANA. The pipe "|" is used as a simple separator between `&lt;version-constraint&gt;`. Each `&lt;version-constraint&gt;` in this pipe-separated list contains a comparator and a version:
  </p>

  <pre>
    &lt;comparator:version&gt;
  </pre>

  <p>This list of `&lt;version-constraint&gt;` are signposts in the version timeline of a package that specify version intervals.</p>

  <p>A `&lt;version&gt;` satisfies a version range specifier if it is contained within any of the intervals defined by these `&lt;version-constraint&gt;`.</p>

  <h2>Using version range specifiers</h2>

  <p>`vers` primary usage is to test if a version is within a range.</p>

  <p>A version is within a version range if falls in any of the intervals defined by a range. Otherwise, the version is outside of the version range.</p>

  <p>Some important usages derived from this include:</p>

  <ul>
    <li><b>Resolving a version range specifier to a list of concrete versions.</b> In this case, the input is one or more known versions of a package. Each version is then tested to check if it lies within or outside the range. For example, given a vulnerability and the <code>vers</code> describing the vulnerable versions of a package, this process is used to determine if an existing package version is vulnerable.</li>
    <li><b>Selecting one of several versions that are within a range.</b> In this case, given several versions that are within a range and several packages that express package dependencies qualified by a version range, a package management tool will determine and select the set of package versions that satisfy all the version ranges constraints of all dependencies. This usually requires deploying heuristics and algorithms (possibly complex such as sat solvers) that are ecosystem- and tool-specific and outside of the scope for this specification; yet <code>vers</code> could be used in tandem with <code>purl</code> to provide an input to this dependencies resolution process.</li>
  </ul>

  <h3>Examples</h3>

  <p>A single version in an npm package dependency:</p>

  <ul>
    <li>originally seen as a dependency on version "1.2.3" in a package.json manifest</li>
    <li>the version range spec is: <code>vers:npm/1.2.3</code></li>
  </ul>

  <p>A list of versions, enumerated:</p>

  <ul>
    <li><code>vers:pypi/0.0.0|0.0.1|0.0.2|0.0.3|1.0|2.0pre1</code></li>
  </ul>

  <p>A complex statement about a vulnerability in a "maven" package that affects multiple branches each with their own fixed versions at <a href="https://repo1.maven.org/maven2/org/apache/tomee/apache-tomee/">https://repo1.maven.org/maven2/org/apache/tomee/apache-tomee/</a> Note how the constraints are sorted:</p>

  <ul>
    <li>"affects Apache TomEE 8.0.0-M1 - 8.0.1, Apache TomEE 7.1.0 - 7.1.2, Apache TomEE 7.0.0-M1 - 7.0.7, Apache TomEE 1.0.0-beta1 - 1.7.5."</li>
    <li>a normalized version range spec is: <code>vers:maven/>=1.0.0-beta1|&lt;=1.7.5|>=7.0.0-M1|&lt;=7.0.7|>=7.1.0|&lt;=7.1.2|>=8.0.0-M1|&lt;=8.0.1</code></li>
    <li>alternatively, four <code>vers</code> express the same range, using one <code>vers</code> for each vulnerable "branches":
      <ul>
        <li><code>vers:tomee/>=1.0.0-beta1|&lt;=1.7.5</code></li>
        <li><code>vers:tomee/>=7.0.0-M1|&lt;=7.0.7</code></li>
        <li><code>vers:tomee/>=7.1.0|&lt;=7.1.2</code></li>
        <li><code>vers:tomee/>=8.0.0-M1|&lt;=8.0.1</code></li>
      </ul>
    </li>
  </ul>

  <p>Converting RubyGems custom syntax for dependency on gem. Note how the pessimistic version constraint is expanded:</p>

  <ul>
    <li><code>'library', '~> 2.2.0', '!= 2.2.1'</code></li>
    <li>the version range spec is: <code>vers:gem/>=2.2.0|!= 2.2.1|&lt;2.3.0</code></li>
  </ul>

  <h3>URI scheme</h3>

  <p>The <code>vers</code> URI scheme is an acronym for "VErsion Range Specifier". It has been selected because it is short, obviously about version and available for a future formal registration for this URI-scheme at the IANA registry.</p>

  <p>The URI scheme is followed by a colon ":".</p>

  <h3><code>&lt;versioning-scheme&gt;</code></h3>

  <p>The <code>&lt;versioning-scheme&gt;</code> (such as <code>npm</code>, <code>deb</code>, etc.) determines:</p>

  <ul>
    <li>the specific notation and conventions used for a version string encoded in this scheme. Versioning schemes often specify a version segments separator and the meaning of each version segment, such as [major.minor.patch] in semver.</li>
    <li>how two versions are compared as greater or lesser to determine if a version is within or outside a range.</li>
    <li>how a versioning scheme-specific range notation can be transformed in the <code>vers</code> simplified notation defined here.</li>
  </ul>

  <p>By convention the versioning scheme <b>should</b> be the same as the <code>Package-URL</code> package type for a given package ecosystem. It is OK to have other schemes beyond the purl type. A scheme could be specific to a single package name.</p>

  <p>The <code>&lt;versioning-scheme&gt;</code> is followed by a slash "/".</p>

  <h3><code>&lt;version-constraint&gt;</code></h3>

  <p>After the <code>&lt;versioning-scheme&gt;</code> and "/" there are one or more <code>&lt;version-constraint&gt;</code> separated by a pipe "|". The pipe "|" has no special meaning beside being a separator.</p>

  <p>Each <code>&lt;version-constraint&gt;</code> of this list is either a single <code>&lt;version&gt;</code> as in <code>1.2.3</code> for example or the combination of a <code>&lt;comparator&gt;</code> and a <code>&lt;version&gt;</code> as in <code>&gt;=2.0.0</code> using this syntax:</p>

  <pre><code>&lt;comparator&gt;&lt;version&gt;</code></pre>

  <p>A single version means that a version equal to this version satisfies the range spec. Equality is based on the equality of two normalized version strings according to their versioning scheme. For most schemes, this is a simple string equality. But schemes can specify normalization and rules for equality such as <code>pypi</code> with PEP440.</p>

  <p>The special star "*" comparator matches any version. It must be used <b>alone</b> exclusive of any other constraint and must not be followed by a version. For example "vers:deb/*" represents all the versions of a Debian package. This includes past, current and possible future versions.</p>

  <p>Otherwise, the <code>&lt;comparator&gt;</code> is one of these comparison operators:</p>

  <ul>
    <li>"!=": Version exclusion or inequality comparator. This means a version must not be equal to the provided version that must be excluded from the range. For example: "!=1.2.3" means that version "1.2.3" is excluded.</li>
    <li>"&lt;", "&lt;=": Lesser than or lesser-or-equal version comparators point to all versions less than or equal to the provided version. For example "&lt;=1.2.3" means less than or equal to "1.2.3".</li>
    <li>"&gt;", "&gt;=": Greater than or greater-or-equal version comparators point to all versions greater than or equal to the provided version. For example "&gt;=1.2.3" means greater than or equal to "1.2.3".</li>
  </ul>

  <p>The <code>&lt;versioning-scheme&gt;</code> defines:</p>

  <ul>
    <li>how to compare two version strings using these comparators, and</li>
    <li>the structure of a version string such as "1.2.3" if any. For instance, the <code>semver</code> specification for version numbers defines a version as composed primarily of three dot-separated numeric segments named major, minor and patch.</li>
  </ul>

  <h2>Normalized, canonical representation and validation</h2>

  <p>The construction and validation rules are designed such that a <code>vers</code> is easier to read and understand by humans and straightforward to process by tools, attempting to avoid the creation of empty or impossible version ranges.</p>

  <ul>
    <li>Spaces are not significant and removed in a canonical form. For example "&lt;1.2.3|&gt;=2.0" and " &lt; 1.2. 3 | &gt; = 2 . 0" are equivalent.</li>
    <li>A version range specifier contains only printable ASCII letters, digits and punctuation.</li>
    <li>The URI scheme and versioning scheme are always lowercase as in <code>vers:npm</code>.</li>
    <li>The versions are case-sensitive, and a versioning scheme may specify its own case sensitivity.</li>
    <li>If a <code>version</code> in a <code>&lt;version-constraint&gt;</code> contains separator or comparator characters (i.e. <code>&gt;&lt;=!*|</code>), it must be quoted using the URL quoting rules. This should be rare in practice.</li>
  </ul>

  <p>The list of <code>&lt;version-constraint&gt;s</code> of a range are signposts in the version timeline of a package. With these few and simple validation rules, we can avoid the creation of most empty or impossible version ranges:</p>

  <ul>
    <li><b>Constraints are sorted by version</b>. The canonical ordering is the versions order. The ordering of <code>&lt;version-constraint&gt;</code> is not significant otherwise but this sort order is needed when checking if a version is contained in a range.</li>
    <li><b>Versions are unique</b>. Each <code>version</code> must be unique in a range and can occur only once in any <code>&lt;version-constraint&gt;</code> of a range specifier, irrespective of its comparators. Tools must report an error for duplicated versions.</li>
    <li><b>There is only one star</b>: "*" must only occur once and alone in a range, without any other constraint or version.</li>
  </ul>

  <p>Starting from a de-duplicated and sorted list of constraints, these extra rules apply to the comparators of any two contiguous constraints to be valid:</p>

  <ul>
    <li>"!=" constraint can be followed by a constraint using any comparator, i.e., any of "=", "!=", "&gt;", "&gt;=", "&lt;", "&lt;=" as comparator (or no constraint).</li>
  </ul>

  <p>Ignoring all constraints with "!=" comparators:</p>

  <ul>
    <li>A "=" constraint must be followed only by a constraint with one of "=", "&gt;", "&gt;=" as comparator (or no constraint).</li>
  </ul>

  <p>And ignoring all constraints with "=" or "!=" comparators, the sequence of constraint comparators must be an alternation of greater and lesser comparators:</p>

  <ul>
    <li>"&lt;" and "&lt;=" must be followed by one of "&gt;", "&gt;=" (or no constraint).</li>
    <li>"&gt;" and "&gt;=" must be followed by one of "&lt;", "&lt;=" (or no constraint).</li>
  </ul>

  <p>Tools must report an error for such invalid ranges.</p>

  <h2>Parsing and validating version range specifiers</h2>

  <p>To parse a version range specifier string:</p>

  <ul>
    <li>Remove all spaces and tabs.</li>
    <li>Start from left, and split once on colon ":".</li>
    <li>The left hand side is the URI-scheme that must be lowercase.
      <ul>
        <li>Tools must validate that the URI-scheme value is <code>vers</code>.</li>
      </ul>
    </li>
    <li>The right hand side is the specifier.</li>
    <li>Split the specifier from left once on a slash "/".</li>
    <li>The left hand side is the <code>&lt;versioning-scheme&gt;</code> that must be lowercase. Tools should validate that the <code>&lt;versioning-scheme&gt;</code> is a known scheme.</li>
    <li>The right hand side is a list of one or more constraints. Tools must validate that this constraints string is not empty ignoring spaces.</li>
    <li>If the constraints string is equal to "*", the <code>&lt;version-constraint&gt;</code> is "*". Parsing is done and no further processing is needed for this <code>vers</code>. A tool should report an error if there are extra characters beyond "*".</li>
    <li>Strip leading and trailing pipes "|" from the constraints string.</li>
    <li>Split the constraints on pipe "|". The result is a list of <code>&lt;version-constraint&gt;</code>. Consecutive pipes must be treated as one and leading and trailing pipes ignored.</li>
    <li>For each <code>&lt;version-constraint&gt;</code>:
      <ul>
        <li>Determine if the <code>&lt;version-constraint&gt;</code> starts with one of the two comparators:
          <ul>
            <li>If it starts with "&gt;=", then the comparator is "&gt;=".</li>
            <li>If it starts with "&lt;=", then the comparator is "&lt;=".</li>
            <li>If it starts with "!=", then the comparator is "!=".</li>
            <li>If it starts with "&lt;", then the comparator is "&lt;".</li>
            <li>If it starts with "&gt;", then the comparator is "&gt;".</li>
            <li>Remove the comparator from <code>&lt;version-constraint&gt;</code> string start. The remaining string is the version.</li>
          </ul>
        </li>
        <li>Otherwise the version is the full <code>&lt;version-constraint&gt;</code> string (which implies an equality comparator of "=")</li>
        <li>Tools should validate and report an error if the version is empty.</li>
        <li>If the version contains a percent "%" character, apply URL quoting rules to unquote this string.</li>
        <li>Append the parsed (comparator, version) to the constraints list.</li>
      </ul>
    </li>
  </ul>

  <p>Finally:</p>

  <ul>
    <li>The results are the <code>&lt;versioning-scheme&gt;</code> and the list of <code>&lt;comparator, version&gt;</code> constraints.</li>
  </ul>

  <p>Tools should optionally validate and simplify the list of <code>&lt;comparator, version&gt;</code> constraints once parsing is complete:</p>

  <ul>
    <li>Sort and validate the list of constraints.</li>
    <li>Simplify the list of constraints.</li>
  </ul>

  <h3>Version constraints simplification</h3>

  <p>Tools can simplify a list of <code>&lt;version-constraint&gt;</code> using this approach:</p>

  <p>These pairs of contiguous constraints with these comparators are valid:</p>

  <ul>
    <li>!= followed by anything</li>
    <li>=, &lt;, or &lt;= followed by =, !=, &gt;, or &gt;=</li>
    <li>&gt;, or &gt;= followed by !=, &lt;, or &lt;=</li>
  </ul>

  <p>These pairs of contiguous constraints with these comparators are redundant and invalid (ignoring any != since they can show up anywhere):</p>

  <ul>
    <li>=, &lt; or &lt;= followed by &lt; or &lt;=: this is the same as &lt; or &lt;=</li>
    <li>&gt; or &gt;= followed by =, &gt; or &gt;=: this is the same as &gt; or &gt;=</li>
  </ul>

  <p>A procedure to remove redundant constraints can be:</p>

  <ul>
    <li>Start from a list of constraints of comparator and version, sorted by version and where each version occurs only once in any constraint.</li>
    <li>If the constraints list contains a single constraint (star, equal or anything) return this list and simplification is finished.</li>
    <li>Split the constraints list in two sub lists:
      <ul>
        <li>a list of "unequal constraints" where the comparator is "!="</li>
        <li>a remainder list of "constraints" where the comparator is not "!="</li>
      </ul>
    </li>
    <li>If the remainder list of "constraints" is empty, return the "unequal constraints" list and simplification is finished.</li>
    <li>Iterate over the constraints list, considering the current and next contiguous constraints, and the previous constraint (e.g., before current) if it exists:
      <ul>
        <li>If current comparator is "&gt;" or "&gt;=" and next comparator is "=", "&gt;" or "&gt;=", discard next constraint</li>
        <li>If current comparator is "=", "&lt;" or "&lt;=" and next comparator is &lt;" or &lt;=", discard current constraint. Previous constraint becomes current if it exists.</li>
        <li>If there is a previous constraint:
          <ul>
            <li>If previous comparator is "&gt;" or "&gt;=" and current comparator is "=", "&gt;" or "&gt;=", discard current constraint</li>
            <li>If previous comparator is "=", "&lt;" or "&lt;=" and current comparator is &lt;" or &lt;=", discard previous constraint</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Concatenate the "unequal constraints" list and the filtered "constraints" list</li>
    <li>Sort by version and return.</li>
  </ul>

  <h3>Checking if a version is contained within a range</h3>

  <p>To check if a "tested version" is contained within a version range:</p>

  <ul>
    <li>Start from a parsed a version range specifier with:
      <ul>
        <li>a versioning scheme</li>
        <li>a list of constraints of comparator and version, sorted by version and where each version occurs only once in any constraint.</li>
      </ul>
    </li>
    <li>If the constraint list contains only one item and the comparator is "*", then the "tested version" is IN the range. Check is finished.</li>
    <li>Select the version equality and comparison procedures suitable for this versioning scheme and use these for all version comparisons performed below.</li>
    <li>If the "tested version" is equal to the any of the constraint versions where the constraint comparator is for equality (any of "=", "&lt;=", or "&gt;=") then the "tested version" is in the range. Check is finished.</li>
    <li>If the "tested version" is equal to the any of the constraint versions where the constraint comparator is "=!" then the "tested version" is NOT in the range. Check is finished.</li>
    <li>Split the constraint list in two sub lists:
      <ul>
        <li>a first list where the comparator is "=" or "!="</li>
        <li>a second list where the comparator is neither "=" nor "!="</li>
      </ul>
    </li>
    <li>Iterate over the current and next contiguous constraints pairs (aka. pairwise) in the second list.</li>
    <li>For each current and next constraint:
      <ul>
        <li>If this is the first iteration and current comparator is "&lt;" or &lt;=" and the "tested version" is less than the current version then the "tested version" is IN the range. Check is finished.</li>
        <li>If this is the last iteration and next comparator is "&gt;" or &gt;=" and the "tested version" is greater than the next version then the "tested version" is IN the range. Check is finished.</li>
        <li>If current comparator is "&gt;" or &gt;=" and next comparator is "&lt;" or &lt;=" and the "tested version" is greater than the current version and the "tested version" is less than the next version then the "tested version" is IN the range. Check is finished.</li>
        <li>If current comparator is "&lt;" or &lt;=" and next comparator is "&gt;" or &gt;=" then these versions are out the range. Continue to the next iteration.</li>
      </ul>
    </li>
    <li>Reaching here without having finished the check before means that the "tested version" is NOT in the range.</li>
  </ul>

  <h3>Notes and caveats</h3>

  <ul>
    <li>Comparing versions from two different versioning schemes is an error. Even though there may be some similarities between the <code>semver</code> version of an npm and the <code>deb</code> version of its Debian packaging, the way versions are compared specific to each versioning scheme and may be different. Tools should report an error in this case.</li>
    <li>All references to sorting or ordering of version constraints means sorting by version. And sorting by versions always implies using the versioning scheme-specified version comparison and ordering.</li>
  </ul>

  <h2>Some of the known versioning schemes</h2>

  <p>These are a few known versioning schemes for some common Package-URL types (aka. <code>ecosystem</code>).</p>

  <ul>
    <li><b>deb</b>: Debian and Ubuntu <a href="https://www.debian.org/doc/debian-policy/ch-relationships.html">https://www.debian.org/doc/debian-policy/ch-relationships.html</a> Debian uses these comparators: &lt;&lt;, &lt;=, =, &gt;= and &gt;&gt;.</li>
    <li><b>rpm</b>: RPM distros <a href="https://rpm-software-management.github.io/rpm/manual/dependencies.html">https://rpm-software-management.github.io/rpm/manual/dependencies.html</a> A simplified rmpvercmp version comparison routine is used by Arch Linux Pacman.</li>
    <li><b>gem</b>: RubyGems <a href="https://guides.rubygems.org/patterns/#semantic-versioning">https://guides.rubygems.org/patterns/#semantic-versioning</a> which is similar to <code>node-semver</code> for its syntax, but does not use semver versions.</li>
    <li><b>npm</b>: npm uses node-semver which is based on semver with its own range notation <a href="https://github.com/npm/node-semver#ranges">https://github.com/npm/node-semver#ranges</a> A similar but different scheme is used by Rust <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html</a> and several other package types may use <code>node-semver</code>-like ranges. But most of these related schemes are not strictly the same as what is implemented in <code>node-semver</code>. For instance PHP <code>composer</code> may need its own scheme as this is not strictly <code>node-semver</code>.</li>
    <li><b>composer</b>: PHP <a href="https://getcomposer.org/doc/articles/versions.md">https://getcomposer.org/doc/articles/versions.md</a></li>
    <li><b>pypi</b>: Python <a href="https://www.python.org/dev/peps/pep-0440/">https://www.python.org/dev/peps/pep-0440/</a></li>
    <li><b>cpan</b>: Perl <a href="https://perlmaven.com/how-to-compare-version-numbers-in-perl-and-for-cpan-modules">https://perlmaven.com/how-to-compare-version-numbers-in-perl-and-for-cpan-modules</a></li>
    <li><b>golang</b>: Go modules <a href="https://golang.org/ref/mod#versions">https://golang.org/ref/mod#versions</a> use <code>semver</code> versions with a specific minimum version resolution algorithm.</li>
    <li><b>maven</b>: Apache Maven supports a math interval notation which is rarely seen in practice <a href="http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html">http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html</a></li>
    <li><b>nuget</b>: NuGet <a href="https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges">https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges</a> Note that Apache Maven and NuGet are following a similar approach with a math-derived intervals syntax as in <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)">https://en.wikipedia.org/wiki/Interval_(mathematics)</a></li>
    <li><b>gentoo</b>: Gentoo <a href="https://wiki.gentoo.org/wiki/Version_specifier">https://wiki.gentoo.org/wiki/Version_specifier</a></li>
    <li><b>alpine</b>: Alpine linux <a href="https://gitlab.alpinelinux.org/alpine/apk-tools/-/blob/master/src/version.c">https://gitlab.alpinelinux.org/alpine/apk-tools/-/blob/master/src/version.c</a> which is using Gentoo-like conventions.</li>
  </ul>

  <p>These are generic schemes, to use sparingly for special cases:</p>

  <ul>
    <li><b>generic</b>: a generic version comparison algorithm (which will be specified later, likely based on a split on any wholly alpha or wholly numeric segments and dealing with digit and string comparisons, like is done in libversion)</li>
    <li><b>none</b>: a generic versioning scheme for a range containing no version. <code>vers:none/*</code> is the only valid vers form for this scheme.</li>
    <li><b>all</b>: a generic versioning scheme for a range containing all versions. <code>vers:all/*</code> is the only valid vers form for this scheme.</li>
    <li><b>intdot</b>: a generic versioning scheme that allows version components to be specified as integers separated by dots, e.g. <code>10.234.5.12</code>. Versions specified in this scheme consist of ASCII digits only, formatted with only non-negative integers, and ignoring leading zeros. Interpretation of the version should stop at the first character that is not a digit or a dot.</li>
    <li><b>lexicographic</b>: a generic versioning scheme that compares versions based on lexicographic order, interpreted as UTF-8. Strings should be compared bytewise as unsigned bytes without normalization. UTF-8 encoding is defined in https://datatracker.ietf.org/doc/html/rfc3629.</li>
    <li><b>semver</b>: a generic scheme that uses the same syntax as <code>semver</code>. It follows the MAJOR.MINOR.PATCH format and is defined in the Semantic Versioning Specification 2.0.0, see <a href="https://semver.org/spec/v2.0.0.html">https://semver.org/spec/v2.0.0.html</a>.</li>
    <li><b>datetime</b>: a generic scheme that uses a timestamp for comparison. The timestamp must adhere to RFC3339, section 5.6, see <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">https://www.rfc-editor.org/rfc/rfc3339#section-5.6</a>.</li>
  </ul>

  <p>A separate document will provide details for each versioning scheme and:</p>

  <ul>
    <li>how to convert its native range notation to the <code>vers</code> notation and back.</li>
    <li>how to compare and sort two versions in a range.</li>
  </ul>

  <p>This versioning schemes document will also explain how to convert CVE and OSV ranges to <code>vers</code>.</p>

  <h2>Implementations</h2>

  <ul>
    <li>Python: <a href="https://github.com/nexB/univers">https://github.com/nexB/univers</a></li>
    <li>Java: <a href="https://github.com/nscuro/versatile">https://github.com/nscuro/versatile</a></li>
    <li>Yours!</li>
  </ul>

  <h2>Related efforts and alternative</h2>

  <ul>
    <li>CUDF defines a generic range notation similar to Debian and integer version numbers from the sequence of versions for universal dependencies resolution <a href="https://www.mancoosi.org/cudf/primer/">https://www.mancoosi.org/cudf/primer/</a></li>
    <li>OSV is an "Open source vulnerability DB and triage service." It defines vulnerable version range semantics using a minimal set of comparators for use with package "ecosystem" and version range "type". <a href="https://github.com/google/osv">https://github.com/google/osv</a></li>
    <li>libversion is a library for general purpose version comparison using a unified procedure designed to work with many package types. <a href="https://github.com/repology/libversion">https://github.com/repology/libversion</a></li>
    <li>unified-range is a library for uniform version ranges based on the Maven version range spec. It supports Apache Maven and npm ranges <a href="https://github.com/snyk/unified-range">https://github.com/snyk/unified-range</a></li>
    <li>dephell specifier is a library to parse and evaluate version ranges and "work with version specifiers (can parse PEP-440, SemVer, Ruby, NPM, Maven)" <a href="https://github.com/dephell/dephell_specifier">https://github.com/dephell/dephell_specifier</a></li>
  </ul>

  <h2>Why not reuse existing version range notations?</h2>

  <p>Most existing version range notations are tied to a specific version string syntax and are therefore not readily applicable to other contexts. For example, the use of elements such as tilde and caret ranges in RubyGems, npm or Dart notations implies that a certain structure exists in the version string (semver or semver- like). The inclusion of these additional comparators is a result of the history and evolution in a given package ecosystem to address specific needs.</p>

  <p>In practice, the unified and reduced set of comparators and syntax defined for <code>vers</code> has been designed such that all these notations can be converted to a <code>vers</code> and back from a <code>vers</code> to the original notation.</p>

  <p>In contrast, this would not be possible with existing notations. For instance, the Python notation may not work with npm semver versions and reciprocally.</p>

  <p>There are likely to be a few rare cases where round tripping from and to <code>vers</code> may not be possible, and in any case round tripping to and from <code>vers</code> should produce equivalent results and even if not strictly the same original strings.</p>

  <p>Another issue with existing version range notations is that they are primarily designed for dependencies and not for vulnerable ranges. In particular, a vulnerability may exist for multiple "version branches" of a given package such as with Django 2.x and 3.x. Several version range notations have difficulties to communicate these as typically all the version constraints must be satisfied. In contrast, a vulnerability can affect multiple disjoint version ranges of a package and any version satisfying these constraints would be vulnerable: it may not be possible to express this with a notation designed exclusively for dependent versions resolution.</p>

  <p>Finally, one of the goals of this spec is to be a compact yet obvious Package-URL companion for version ranges. Several existing and closely related notations designed for vulnerable ranges are verbose specifications designed for use in API with larger JSON documents.</p>

  <h3>Why not use the OSV Ranges?</h3>

  <p>See:</p>

  <ul>
    <li><a href="https://ossf.github.io/osv-schema/">https://ossf.github.io/osv-schema/</a></li>
  </ul>

  <p><code>vers</code> and the OSSF OSV schema vulnerable ranges are equivalent and <code>vers</code> provides a compact range notation while OSV provides a more verbose JSON notation.</p>

  <p><code>vers</code> borrows the design from and was informed by the OSV schema spec and its authors.</p>

  <p>OSV uses a minimalist set of only three comparators:</p>

  <ul>
    <li>"=" to enumerate versions,</li>
    <li>"&gt;=" for the version that introduced a vulnerability, and</li>
    <li>"&lt;" for the version that fixed a vulnerability.</li>
  </ul>

  <p>OSV Ranges support neither "&gt;" nor "!=" comparators making it difficult to express some ranges that must exclude a version. This may not be an issue for most vulnerable ranges yet:</p>

  <ul>
    <li>this makes it difficult or impossible to precisely express certain dependency and vulnerable ranges when a version must be excluded and the set of existing versions is not yet known,</li>
    <li>this make some ranges more verbose such as with the CVE v5 API ranges notation that can include their upper limit and would need two constraints.</li>
  </ul>

  <p>Another high level difference between the two specifications is the codes used to qualify a range package "ecosystem" value that resembles closely the Package-URL package "type" used in <code>vers</code>. This spec will provide a strict mapping between the OSV ecosystem and the <code>vers</code> versioning schemes values.</p>

  <h3>Why not use the CVE v5 API Ranges?</h3>

  <p>See:</p>

  <ul>
    <li><a href="https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L303">https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L303</a></li>
    <li><a href="https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L123">https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L123</a></li>
  </ul>

  <p>The version 5 of the CVE JSON data format defines version ranges with a starting version, a versionType, and an upper limit for the version range as lessThan or lessThanOrEqual or as an enumeration of versions. The versionType and the package collectionURL possible values are only indicative and left out of this specification and both seem strictly equivalent to the Package-URL "type" on the one hand and the <code>vers</code> versioning scheme on the other hand.</p>

  <p>The semantics and expressiveness of each range are similar and <code>vers</code> provides a compact notation rather than a more verbose JSON notation. <code>vers</code> supports strictly the conversion of any CVE v5 range to its notation and further provides a concrete list of well known versioning schemes. <code>vers</code> design was informed by the CVE v5 API schema spec and its authors.</p>

  <p>When CVE v5 becomes active, this spec will provide a strict mapping between the CVE <code>versionType</code> and the <code>vers</code> versioning schemes values. Furthermore, this spec and the Package-URL "types" should be updated accordingly to provide a mapping with the upcoming CVE <code>collectionURL</code> that will be effectively used.</p>

  <p>There is one issue with CVE v5: it introduces a new trailing "*" notation that does not exist in most version ranges notations and may not be computable easily in many cases. The description of the "lessThan" property is:</p>

  <blockquote>
    <p>The non-inclusive upper limit of the range. This is the least version NOT in the range. The usual version syntax is expanded to allow a pattern to end in an asterisk (*), indicating an arbitrarily large number in the version ordering. For example, {version: 1.0 lessThan: 1.*} would describe the entire 1.X branch for most range kinds, and {version: 2.0, lessThan: *} describes all versions starting at 2.0, including 3.0, 5.1, and so on.</p>
  </blockquote>

  <p>The conversion to <code>vers</code> range should be:</p>

  <ul>
    <li>with a version 1.0 and "lessThan": "*", the <code>vers</code> equivalent is: <code>&gt;=1.0</code>.</li>
    <li>with a version 1.0 and "lessThan": "2.*", the <code>vers</code> equivalent can be computed for <code>semver</code> versions as <code>&gt;=1.0|&lt;2</code> but this is not accurate because the versioning schemes have different rules. For instance, pre-release may be treated in some case as part of the v1. branch and in some other cases as part of the v2. branch. It is not clear if with "2.*" the CVE v5 spec means:
      <ul>
        <li><code>&lt;2</code></li>
        <li>or something that excludes any version string that starts with <code>2.</code></li>
      </ul>
    </li>
  </ul>

  <p>And in this case, with the expression "lessThan": "2.*" using a <code>semver</code> version, it is not clear if <code>2.0.0-alpha</code> is "lessThan"; semver sorts it before <code>2.0</code> and after <code>1.0</code>, e.g., in <code>semver</code> <code>2.0.0-alpha</code> is "less than" <code>2</code>.</p>

  <h3>Why not use the NVD CPE Ranges?</h3>

  <p>See:</p>

  <ul>
    <li><a href="https://nvd.nist.gov/vuln/vulnerability-detail-pages#divRange">https://nvd.nist.gov/vuln/vulnerability-detail-pages#divRange</a></li>
    <li><a href="https://nvd.nist.gov/developers/vulnerabilities#divResponse">https://nvd.nist.gov/developers/vulnerabilities#divResponse</a></li>
    <li><a href="https://csrc.nist.gov/schema/nvd/feed/1.1/nvd_cve_feed_json_1.1.schema">https://csrc.nist.gov/schema/nvd/feed/1.1/nvd_cve_feed_json_1.1.schema</a></li>
  </ul>

  <p>The version ranges notation defined in the JSON schema of the CVE API payload uses these four fields: <code>versionStartIncluding</code>, <code>versionStartExcluding</code>, <code>versionEndIncluding</code> and <code>versionEndExcluding</code>. For example:</p>

  <pre><code>"versionStartIncluding": "7.3.0",
"versionEndExcluding": "7.3.31",
"versionStartExcluding" : "9.0.0",
"versionEndIncluding" : "9.0.46",</code></pre>

  <p>In addition to these ranges, the NVD publishes a list of concrete CPEs with versions resolved for a range with daily updates at <a href="https://nvd.nist.gov/vuln/data-feeds#cpeMatch">https://nvd.nist.gov/vuln/data-feeds#cpeMatch</a></p>

  <p>Note that the NVD CVE configuration is a complex specification that goes well beyond version ranges and is used to match comprehensive configurations across multiple products and version ranges. <code>vers</code> focus is exclusively versions.</p>

  <p>In contrast with <code>vers</code> compact notation, the NVD JSON notation is more verbose, yet <code>vers</code> supports strictly the conversion of any CPE range.</p>

  <h3>Why not use node-semver ranges?</h3>

  <p>See:</p>

  <ul>
    <li><a href="https://github.com/npm/node-semver#ranges">https://github.com/npm/node-semver#ranges</a></li>
  </ul>

  <p>The node-semver spec is similar to but much more complex than this spec. This is an AND of ORs constraints with a few practical issues:</p>

  <ul>
    <li>A space means "AND", therefore white spaces are significant. Having significant white spaces in a string makes normalization more complicated and may be a source of confusion if you remove the spaces from the string. <code>vers</code> avoids the ambiguity of spaces by ignoring them.</li>
    <li>The advanced range syntax has grown to be rather complex using hyphen ranges, stars ranges, carets and tilde constructs that are all tied to the JavaScript and npm ways of handling versions in their ecosystem and are bound furthermore to the semver semantics and its npm implementation. These are not readily reusable elsewhere. The multiple comparators and modifiers make the notation grammar more complex to parse and process for a machine and harder to read for human.</li>
  </ul>

  <p>Notations that are directly derived from node-semver as used in Rust and PHP Composer have the same issues.</p>

  <h3>Why not use Python PEP-0440 ranges?</h3>

  <p>See:</p>

  <ul>
    <li><a href="https://www.python.org/dev/peps/pep-0440/#version-specifiers">https://www.python.org/dev/peps/pep-0440/#version-specifiers</a></li>
  </ul>

  <p>The Python pep-0440 "Version Identification and Dependency Specification" provides a comprehensive specification for Python package versioning and a notation for "version specifiers" to express the version constraints of dependencies.</p>

  <p>This specification is similar to this <code>vers</code> spec, with more operators and aspects specific to the versions used only in the Python ecosystem.</p>

  <ul>
    <li>In particular pep-0440 uses tilde, triple equal and wildcard star operators that are specific to how two Python versions are compared.</li>
    <li>The comma separator between constraints is a logical "AND" rather than an "OR". The "OR" does not exist in the syntax making some version ranges harder to express, in particular for vulnerabilities that may affect several exact versions or ranges for multiple parallel release branches. Ranges such as "Django 1.2 or later, or Django 2.2 or later or Django 3.2 or later" are difficult to express without an "OR" logic.</li>
  </ul>

  <h3>Why not use RubyGems requirements notation?</h3>

  <p>See:</p>

  <ul>
    <li><a href="https://guides.rubygems.org/patterns/#declaring-dependencies">https://guides.rubygems.org/patterns/#declaring-dependencies</a></li>
  </ul>

  <p>The RubyGems specification suggests but does not enforce using semver. It uses operators similar to the <code>node-semver</code> spec with the difference of the "~&gt;" aka. pessimistic operator vs. a plain "~" tilde used in node-semver. This operator implies some semver-like versioning, yet gem versions are not strictly semver. This makes the notation complex to implement and impractical to reuse in places that do not use the same Ruby-specific semver-like semantics.</p>

  <h3>Why not use fewer comparators with only =, &gt;= and &lt;?</h3>

  <p>For instance, the OSV schema adopts a reduced set of only three comparators:</p>

  <ul>
    <li>"=" is implied when used to enumerate vulnerable versions</li>
    <li>"&gt;=" (greater or equal) is for the version that introduces a vulnerability</li>
    <li>"&lt;" (lesser) is for the version that fixes a vulnerability</li>
  </ul>

  <p>This approach is simpler and works well for most vulnerable ranges but it faces limitations when converting from other notations:</p>

  <ul>
    <li>"&gt;" cannot be converted reliably to "&gt;=" unless you know all the versions and these will never change.</li>
    <li>"&lt;=" cannot be converted reliably to "&lt;" unless you know all the versions and these will never change.</li>
    <li>"!=" cannot be converted reliably: there is no "&gt;" comparator to create an unequal equivalent of "&gt;&lt;"; and a combo of "&gt;=" and "&lt;" is not equivalent to inequality unless you know all the versions and these will never change.</li>
  </ul>

  <h3>Why not use richer comparators such as tilde, caret and star?</h3>

  <p>Some existing notations such as used with npm, gem, python, or composer provide syntactic shorthand such as:</p>

  <ul>
    <li>a "pessimistic operator" using tilde, ~&gt; or =~ as in "~1.3" or "~&gt;1.2.3"</li>
    <li>a caret ^ prefix as in "^ 1.2"</li>
    <li>using a star in a version segment as in "1.2.*"</li>
    <li>dash-separated ranges as in "1.2 - 1.4"</li>
    <li>arbitrary string equality such as "===1.2"</li>
  </ul>

  <p>Most of these notations can be converted without loss to the <code>vers</code> notation. Furthermore these notations typically assume a well defined version string structure specific to their package ecosystem and are not reusable in another ecosystem that would not use the exact same version conventions.</p>

  <p>For instance, the tilde and caret notations demand that you can reliably infer the next version (aka. "bump") from a given version; this is possible only if the versioning scheme supports this operation reliably for all its accepted versions.</p>

  <h3>Why not use mathematical interval notation for ranges?</h3>

  <p>Apache Maven and NuGet use a mathematical interval notation with comma-separated "[", "]", "(" and ")" to declare version ranges.</p>

  <p>All other known range notations use the more common "&gt;", "&lt;", and "=" as comparators. <code>vers</code> adopts this familiar approach.</p>

  <h2>References</h2>

  <p>Here are some of the discussions that led to the creation of this specification:</p>

  <ul>
    <li><a href="https://github.com/package-url/purl-spec/issues/66">https://github.com/package-url/purl-spec/issues/66</a></li>
    <li><a href="https://github.com/package-url/purl-spec/issues/84">https://github.com/package-url/purl-spec/issues/84</a></li>
    <li><a href="https://github.com/package-url/purl-spec/pull/93">https://github.com/package-url/purl-spec/pull/93</a></li>
    <li><a href="https://github.com/nexB/vulnerablecode/issues/119">https://github.com/nexB/vulnerablecode/issues/119</a></li>
    <li><a href="https://github.com/nexB/vulnerablecode/issues/140">https://github.com/nexB/vulnerablecode/issues/140</a></li>
    <li><a href="https://github.com/nexB/univers/pull/11">https://github.com/nexB/univers/pull/11</a></li>
  </ul>

  <h2>License</h2>

  <p>This document is licensed under the MIT license</p>
</emu-annex>

<emu-annex id="sec-example">
  <h1>Example CLE document</h1>
  <pre><code class="json">
{
  "$schema": "https://TODO/cle.v1.0.0.json",
  "identifier": "pkg:npm/example-component",
  "updatedAt": "2021-01-15T00:00:00Z",
  "definitions": {
    "support": [
      {
        "id": "standard",
        "description": "Standard product support policy",
        "url": "https://example.com/support/standard"
      }
    ]
  },
  "events": [
    {
      "id": 5,
      "type": "withdrawn",
      "effective": "2021-01-15T00:00:00Z",
      "published": "2021-01-15T00:00:00Z",
      "eventId": 2,
      "reason": "The endOfSupport date was incorrect.",
      "references": [
        "https://example.com/support-correction"
      ]
    },
    {
      "id": 4,
      "type": "endOfSupport",
      "effective": "2021-01-01T00:00:00Z",
      "published": "2021-01-01T00:00:00Z",
      "versions": [
        {
          "range": "vers:npm/>=1.0.0|<2.0.0"
        }
      ],
      "supportId": "standard"
    },
    {
      "id": 3,
      "type": "componentRenamed",
      "effective": "2020-01-01T00:00:00Z",
      "published": "2020-01-01T00:00:00Z",
      "description": "Component renamed due to acquisition",
      "identifiers": [
        {
          "type": "PURL",
          "value": "pkg:npm/new-component"
        }
      ]
    },
    {
      "id": 2,
      "type": "endOfSupport",
      "effective": "2020-01-01T00:00:00Z",
      "published": "2020-01-01T00:00:00Z",
      "versions": [
        {
          "range": "vers:npm/>=1.0.0|<2.0.0"
        }
      ],
      "supportId": "standard"
    },
    {
      "id": 1,
      "type": "released",
      "effective": "2019-01-01T00:00:00Z",
      "published": "2019-01-01T00:00:00Z",
      "version": "1.0.0",
      "license": "MIT"
    }
  ]
}
  </code></pre>
</emu-annex>

<emu-annex id="sec-colophon" back-matter>
  <h1>Colophon</h1>
  <p>This Standard is authored on <a href="https://github.com/Ecma-TC54/ECMA-xxx-CLE">GitHub</a> in a plaintext source format called <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a>. Ecmarkup is an HTML and Markdown dialect that provides a framework and toolset for authoring Ecma specifications in plaintext and processing the specification into a full-featured HTML rendering that follows the editorial conventions for this document. Ecmarkup builds on and integrates a number of other formats and technologies including <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a> for defining syntax and <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a> for authoring algorithm steps. PDF renderings of this Standard are produced using a print stylesheet which takes advantage of the CSS Paged Media specification and is converted using <a href="https://www.princexml.com/">PrinceXML</a>.</p>
  <p>Prior editions of this Standard were authored using Word—the Ecmarkup source text that formed the basis of this edition was produced by converting the ECMAScript 2015 Word document to Ecmarkup using an automated conversion tool.</p>
</emu-annex>
